#lang racket/base
(require racket/list
         db
         json)

; An app is a (app db)
; where db is an sqlite connection
(struct app (db))

; A user is a (user id name)
; where id is an integer, and name is a string
(struct user (userid name))
; user->jsexpr : user -> hasheq
; takes a user and outputs its jsexpr representation as a hasheq
(define (user->jsexpr user)
   (hasheq 'name (user-name user)))

; A day is a (day dayid userid datestring)
; where dayid is an integer, userid is an integer, and datestring is a string
(struct day (dayid userid datestring))
; day->jsexpr : day -> hasheq
; takes a day and outputs its jsexpr representation as a hasheq
(define (day->jsexpr day)
   (hasheq 'datestring (day-datestring day)))

; A timechunk is a (timechunk timechunkid dayid userid start end categoryid)
; where timechunkid is an integer, dayid is an integer, userid is an integer,
; start is a string, end is a string, and categoryid is an integer
(struct timechunk (timechunkid dayid userid start end categoryid))
; timechunk->jsexpr : timechunk -> hasheq
; takes a timechunk and outputs its jsexpr representation as a hasheq
(define (timechunk->jsexpr chunk)
  (hasheq 'timechunkid (timechunk-timechunkid chunk)
          'start (timechunk-start chunk)
          'end (timechunk-end chunk)
          'categoryid (timechunk-categoryid chunk)))

; a category is a (category categoryid name color)
; where categoryid is an integer, name is a string, and color is a string
(struct category (categoryid name color))
; category->jsexpr : category -> hasheq
; takes a category and outputs its jsexpr representation as a hasheq
(define (category->jsexpr category)
  (hasheq 'categoryid (category-categoryid category)
          'name (category-name category)
          'color (category-color category)))

; app->most-recent-pk : app -> integer
; takes an app and gets the most recent autogenerated primary key (usually an integer id)
(define (app->most-recent-pk an-app)
  (query-value (app-db an-app) "SELECT last_insert_rowid()"))

; initialize-app! : path -> app
; sets up app with database (if it does not exist already)
(define (initialize-app! home)
  (define db (sqlite3-connect #:database home #:mode 'create))
  (define the-app (app db))
  (unless (table-exists? db "users")
    (println "creating table users")
    (query-exec db "CREATE TABLE users (userid INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE)")
    (app-insert-user! the-app "tommy")
    (app-insert-user! the-app "connor"))
  (unless (table-exists? db "days")
    (println "creating table days")
    (query-exec db
                (string-append
                 "CREATE TABLE days "
                 "(dayid INTEGER PRIMARY KEY, userid INTEGER, "
                 "date TEXT, "
                 "UNIQUE (userid, date), "
                 "FOREIGN KEY (userid) REFERENCES users (userid))"))
    (user-insert-day! the-app (first (app-users the-app))
                      "2019-07-16T00:00:00.000")
    (user-insert-day! the-app (second (app-users the-app))
                      "2019-07-16T00:00:00.000"))

  (unless (table-exists? db "categories")
    (println "creating table categories")
    (query-exec db
                (string-append
                 "CREATE TABLE categories "
                 "(categoryid INTEGER PRIMARY KEY, userid INTEGER,"
                 " name TEXT NOT NULL, color TEXT NOT NULL, "
                 "UNIQUE (userid, name), FOREIGN KEY (userid) REFERENCES users (userid))"))
    (app-insert-category! the-app "homework" "AB2567" (first (app-users the-app)))
    (app-insert-category! the-app "gym" "0CAB99" (first (app-users the-app))))

  (unless (table-exists? db "timechunks")
    (println "creating table timechunks")
    (query-exec db
                (string-append
                 "CREATE TABLE timechunks "
                 "(timechunkid INTEGER PRIMARY KEY, dayid INTEGER, "
                 "userid INTEGER, "
                 "start TEXT, end TEXT, categoryid INTEGER, "
                 "FOREIGN KEY (userid) REFERENCES users (userid), "
                 "FOREIGN KEY (categoryid) REFERENCES categories (categoryid), "
                 "FOREIGN KEY (dayid) REFERENCES days (dayid))"))
    (let* ([user (first (app-users the-app))]
           [day (first (user-days the-app user))]
           [category (first (app-categories the-app user))]
           [other-category (second (app-categories the-app user))])
      (println (user-name user))
      (println (day-datestring day))
      (println category)
      (day-insert-timechunk!
       the-app user day "2019-07-16T00:00:00.000" "2019-07-16T10:30:00.000"
       (category-categoryid category))
      (day-insert-timechunk!
       the-app user day "2019-07-16T10:30:00.000" "2019-07-16T11:30:00.000"
       (category-categoryid other-category))))
  the-app)

; app-users : app -> (listof user)
; Queries the apps user ids and converts them into user structs
(define (app-users an-app)
  (define (vec->user uvec)
    (user (vector-ref uvec 0) (vector-ref uvec 1)))
  (map vec->user
       (query-rows
        (app-db an-app)
        "SELECT userid, username FROM users")))

; app-user : app string -> user
; Queries the apps users by username and returns 
(define (app-user an-app username)
  (define (vec->user uvec)
    (user (vector-ref uvec 0) (vector-ref uvec 1)))
  (vec->user 
   (query-row
    (app-db an-app)
    "SELECT userid, username FROM users WHERE username = ?"
    username)))

; app-categories : app user -> (listof category)
; Queries the apps category ids converts them into category structs
(define (app-categories an-app a-user)
  (define (vec->category cvec)
    (category (vector-ref cvec 0) (vector-ref cvec 1) (vector-ref cvec 2)))
  (map vec->category
       (query-rows
        (app-db an-app)
        "SELECT categoryid, name, color FROM categories WHERE userid = ?"
        (user-userid a-user))))

; app-insert-category! : app string string user -> void
; Consumes an app, a category name string, a color name string, and a user struct
; As a side-effect adds the given category to list of categories for given user
(define (app-insert-category! an-app name color a-user)
  (query-exec
   (app-db an-app)
   "INSERT INTO categories (name, color, userid) VALUES (?, ?, ?)"
   name color (user-userid a-user))
  (app->most-recent-pk an-app))

; app-remove-category! : app integer -> void
; Consumes an app, and a category primary key
; As a side-effect removes the given category from list of categories
(define (app-remove-category! an-app pk)
  (query-exec
   (app-db an-app)
   "DELETE FROM categories WHERE categoryid = ? "
   pk))

; app-insert-user! : app string -> void
; Consumes an app and a username string
; As a side-effect adds the given user to the table of users
(define (app-insert-user! an-app uname) 
  (query-exec
   (app-db an-app)
   "INSERT OR IGNORE INTO users (username) VALUES (?)"
   uname))

; day-instert-timechunk! : app user day string string integer -> integer
; Consumes an app, a day, a user, two timestamp strings, and a categoryid integer
; Returns the integer primary key of the item that was inserted
; As a side-effect adds timechunk to table with corresponding data
(define (day-insert-timechunk! an-app a-user a-day starttime endtime categoryid)
  (query-exec
   (app-db an-app)
   "INSERT INTO timechunks (userid, dayid, start, end, categoryid) VALUES (?, ?, ?, ?, ?)"
   (user-userid a-user) (day-dayid a-day) starttime endtime categoryid)
  (app->most-recent-pk an-app))

; day-update-timechunk! : app integer string string -> void
; Consumes an app, a timechunkid, and two timestamp strings.
; As a side-effect updates timechunk in table with corresponding data
(define (day-update-timechunk! an-app timechunkid starttime endtime)
  (query-exec
   (app-db an-app)
   (string-append
    "UPDATE timechunks SET "
    "start = ?, end = ? "
    "WHERE timechunkid = ?")
   starttime endtime timechunkid)
  (app->most-recent-pk an-app))

; day-remove-timechunk! : app integer -> void
; Consumes an app and an timechunk primary key integer
; As a side-effect removes timechunk in table with associated data
(define (day-remove-timechunk! an-app timechunkid)
  (query-exec
   (app-db an-app)
   "DELETE FROM timechunks WHERE timechunkid = ?"
   timechunkid))

; day-timechunks! : app day user -> (listof timechunk)
; Consumes an app, a day struct, and a user struct, and returns a list of timechunk structs
; Returns the timechunk structs from database associated with given day and user
(define (day-timechunks an-app a-day a-user)
  (println (day-dayid a-day)) (println(user-userid a-user))
  (define (vec->timechunk dvec)
    (timechunk (vector-ref dvec 0) (vector-ref dvec 1)
               (vector-ref dvec 2) (vector-ref dvec 3)
               (vector-ref dvec 4) (vector-ref dvec 5)))
  (map vec->timechunk
       (query-rows
        (app-db an-app)
        "SELECT timechunkid, dayid, userid, start, end, categoryid FROM timechunks WHERE dayid = ? AND userid = ?"
        (day-dayid a-day) (user-userid a-user))))

; user-insert-day! : app user string -> void
; Consumes an app, a user, and a timestring
; As a side-effect adds the given day to the table of days
(define (user-insert-day! an-app a-user timestring)
  (query-exec
   (app-db an-app)
   "INSERT OR IGNORE INTO days (userid, date) VALUES (?, ?)"
   (user-userid a-user) timestring))

; user-days : app user -> (listof day)
; Consumes an app and a user, and produces a list of days
; Returns a list of day structs associated with given user
(define (user-days an-app user)
  (define (vec->day dvec)
    (day (vector-ref dvec 0) (vector-ref dvec 1) (vector-ref dvec 2)))
  (map vec->day
       (query-rows
        (app-db an-app)
        "SELECT dayid, userid, date FROM days WHERE userid = ?"
        (user-userid user))))

; user->day : app user string -> day
; Consumes an app, a user, and a datestring, and produces a day struct
; Returns the daystruct associated with that user and daystring
; As a side effect, a new day may be added if it is not already in db
(define (user-day an-app user datestring)
  (println user)
  (println datestring)
  (define (vec->day dvec)
    (println dvec)
    (day (vector-ref dvec 0) (vector-ref dvec 1) (vector-ref dvec 2)))
  (vec->day
   (query-row
    (app-db an-app)
    "SELECT dayid, userid, date FROM days WHERE userid = ? AND date = ?"
    (user-userid user) datestring)))

(provide initialize-app!
         user-days user-day user-insert-day!
         day-insert-timechunk! day-update-timechunk! day-remove-timechunk!
         app-users app-user app-insert-user!
         app-categories app-insert-category! app-remove-category!
         user-name day-dayid
         category-name category-color
         user->jsexpr timechunk->jsexpr category->jsexpr
         day-timechunks)
