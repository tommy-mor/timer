#lang racket/base
(require racket/list
         db
         json)

;TODO write macro to automatically write json funciton for struct
;TODO add userid to timechunk table

; An app is a (app db)
; where db is an sqlite connection
(struct app (db))

; A user is a (user id name)
; where id is an integer, and name is a string
(struct user (userid name))
; takes a user and outputs its jsexpr representation
(define (user->jsexpr p)
   (hasheq 'name (user-name p)))

; A day is a (day dayid userid datestring)
; where dayid is an integer, userid is an integer, and datestring is a string
(struct day (dayid userid datestring))
; takes a day and outputs its jsexpr representation
(define (day->jsexpr p)
   (hasheq 'datestring (day-datestring p)))

; A timechunk is a (timechunk timechunkid dayid userid start end categoryid)
; where timechunkid is an integer, dayid is an integer, userid is an integer,
; start is a string, end is a string, and categoryid is an integer
(struct timechunk (timechunkid dayid userid start end categoryid))
; takes a timechunk and outputs its jsexpr representation
(define (timechunk->jsexpr t)
  (hasheq 'timechunkid (timechunk-timechunkid t)
          'start (timechunk-start t)
          'end (timechunk-end t)
          'categoryid (timechunk-categoryid t)))

; a category is a (category categoryid name color)
; where categoryid is an integer, name is a string, and color is a string
(struct category (categoryid name color))
; takes a category and outputs its jsexpr representation
(define (category->jsexpr t)
  (hasheq 'categoryid (category-categoryid t)
          'name (category-name t)
          'color (category-color t)))
; takes an app and gets the most recent autogenerated primary key (usually an integer id)
; where an-app is an app a
(define (app->most-recent-pk an-app)
  (query-value (app-db an-app) "SELECT last_insert_rowid()"))

;; TODO add data examples here
;; TODO add function tests

; initialize-app! : path? -> app?
; sets up app with database (if it does not exist already)
(define (initialize-app! home)
  (define db (sqlite3-connect #:database home #:mode 'create))
  (define the-app (app db))
  (unless (table-exists? db "users")
    (println "creating table users")
    (query-exec db "CREATE TABLE users (userid INTEGER PRIMARY KEY, username TEXT NOT NULL UNIQUE)")
    (app-insert-user! the-app "tommy")
    (app-insert-user! the-app "connor"))
  (unless (table-exists? db "days")
    (println "creating table days")
    (query-exec db
                (string-append
                 "CREATE TABLE days "
                 "(dayid INTEGER PRIMARY KEY, userid INTEGER, "
                 "date TEXT, "
                 "UNIQUE (userid, date), "
                 "FOREIGN KEY (userid) REFERENCES users (userid))"))
    (user-insert-day! the-app (first (app-users the-app))
                      "2019-07-16T00:00:00.000")
    (user-insert-day! the-app (second (app-users the-app))
                      "2019-07-16T00:00:00.000"))

  (unless (table-exists? db "categories")
    (println "creating table categories")
    (query-exec db
                (string-append
                 "CREATE TABLE categories "
                 "(categoryid INTEGER PRIMARY KEY, userid INTEGER,"
                 " name TEXT NOT NULL, color TEXT NOT NULL, "
                 "UNIQUE (userid, name), FOREIGN KEY (userid) REFERENCES users (userid))"))
    (app-insert-category! the-app "homework" "AB2567" (first (app-users the-app)))
    (app-insert-category! the-app "gym" "0CAB99" (first (app-users the-app))))

  (unless (table-exists? db "timechunks")
    (println "creating table timechunks")
    (query-exec db
                (string-append
                 "CREATE TABLE timechunks "
                 "(timechunkid INTEGER PRIMARY KEY, dayid INTEGER, "
                 "userid INTEGER, "
                 "start TEXT, end TEXT, categoryid INTEGER, "
                 "FOREIGN KEY (userid) REFERENCES users (userid), "
                 "FOREIGN KEY (categoryid) REFERENCES categories (categoryid), "
                 "FOREIGN KEY (dayid) REFERENCES days (dayid))"))
    (let* ([user (first (app-users the-app))]
           [day (first (user-days the-app user))]
           [category (first (app-categories the-app user))]
           [other-category (second (app-categories the-app user))])
      (println (user-name user))
      (println (day-datestring day))
      (println category)
      (day-insert-timechunk!
       the-app user day "2019-07-16T00:00:00.000" "2019-07-16T10:30:00.000"
       (category-categoryid category))
      (day-insert-timechunk!
       the-app user day "2019-07-16T10:30:00.000" "2019-07-16T11:30:00.000"
       (category-categoryid other-category))))
  the-app)

; app-users : app -> (listof user?)
; Queries the apps user ids and converts them into user structs
(define (app-users an-app)
  (define (vec->user uvec)
    (user (vector-ref uvec 0) (vector-ref uvec 1)))
  (map vec->user
       (query-rows
        (app-db an-app)
        "SELECT userid, username FROM users")))

; app-user : app -> user?
; Queries the apps users and returns 
(define (app-user an-app username)
  (define (vec->user uvec)
    (user (vector-ref uvec 0) (vector-ref uvec 1)))
  (vec->user 
   (query-row
    (app-db an-app)
    "SELECT userid, username FROM users WHERE username = ?"
    username)))

; app-categories : app user -> (listof category?)
; Queries the apps category ids converts them into category structs
(define (app-categories an-app a-user)
  (define (vec->category cvec)
    (category (vector-ref cvec 0) (vector-ref cvec 1) (vector-ref cvec 2)))
  (map vec->category
       (query-rows
        (app-db an-app)
        "SELECT categoryid, name, color FROM categories WHERE userid = ?"
        (user-userid a-user))))

; app-insert-category! : app? string string -> void
; Consumes an app, a category name string and a color name string
; As a side-effect adds the given category to list of categories
(define (app-insert-category! an-app name color a-user)
  (query-exec
   (app-db an-app)
   "INSERT INTO categories (name, color, userid) VALUES (?, ?, ?)"
   name color (user-userid a-user))
  (app->most-recent-pk an-app))

; app-remove-category! : app? integer -> void
; Consumes an app, and a category primary key
; As a side-effect removes the given category from list of categories
(define (app-remove-category! an-app pk)
  (query-exec
   (app-db an-app)
   "DELETE FROM categories WHERE categoryid = ? "
   pk))

; app-insert-user! : app? string -> void
; Consumes an app and a user name string
; As a side-effect adds the given user to the table of users
(define (app-insert-user! an-app uname) 
  (query-exec
   (app-db an-app)
   "INSERT OR IGNORE INTO users (username) VALUES (?)"
   uname))

; day-instert-timechunk! : app? day string string category -> integer
; Consumes an app, a day, two timestamp strings, and a category.
; Returns the integer primary key of the item that was inserted
; As a side-effect adds timechunk to table with corresponding data
(define (day-insert-timechunk! an-app a-user a-day starttime endtime categoryid)
  (println "insert")
  (println starttime)
  (println endtime)
  (query-exec
   (app-db an-app)
   "INSERT INTO timechunks (userid, dayid, start, end, categoryid) VALUES (?, ?, ?, ?, ?)"
   (user-userid a-user) (day-dayid a-day) starttime endtime categoryid)
  (app->most-recent-pk an-app))

; day-update-timechunk! : app? integer string string -> void
; Consumes an app, a timechunkid, and two timestamp strings.
; As a side-effect updates timechunk in table with corresponding data
(define (day-update-timechunk! an-app timechunkid starttime endtime)
  (query-exec
   (app-db an-app)
   (string-append
    "UPDATE timechunks SET "
    "start = ?, end = ? "
    "WHERE timechunkid = ?") ; TODO finish this using timechunkid
   starttime endtime timechunkid)
  (app->most-recent-pk an-app))

; day-remove-timechunk! : app? integer -> void
; Consumes an app and an integer, and returns void
; As a side-effect removes timechunk in table with associated data
(define (day-remove-timechunk! an-app timechunkid)
  (query-exec
   (app-db an-app)
   "DELETE FROM timechunks WHERE timechunkid = ?"
   timechunkid))

(define (day-timechunks an-app a-day a-user)
  (println (day-dayid a-day)) (println(user-userid a-user))
  (define (vec->timechunk dvec)
    (timechunk (vector-ref dvec 0) (vector-ref dvec 1)
               (vector-ref dvec 2) (vector-ref dvec 3)
               (vector-ref dvec 4) (vector-ref dvec 5)))
  (map vec->timechunk
       (query-rows
        (app-db an-app)
        "SELECT timechunkid, dayid, userid, start, end, categoryid FROM timechunks WHERE dayid = ? AND userid = ?"
        (day-dayid a-day) (user-userid a-user))))

; user-insert-day! : app? user string -> user
; Consumes an app, a user, and a timestring
; As a side-effect adds the given day to the table of days
(define (user-insert-day! an-app user timestring)
  (query-exec
   (app-db an-app)
   "INSERT OR IGNORE INTO days (userid, date) VALUES (?, ?)"
   (user-userid user) timestring))

; appusers : app user -> (listof day?)
; Queries the days for a given user and converts them to day structs
(define (user-days an-app user)
  (define (vec->day dvec)
    (day (vector-ref dvec 0) (vector-ref dvec 1) (vector-ref dvec 2)))
  (map vec->day
       (query-rows
        (app-db an-app)
        "SELECT dayid, userid, date FROM days WHERE userid = ?"
        (user-userid user))))

(define (user-day an-app user datestring)
  (println user)
  (println datestring)
  (define (vec->day dvec)
    (println dvec)
    (day (vector-ref dvec 0) (vector-ref dvec 1) (vector-ref dvec 2)))
  (vec->day
   (query-row
    (app-db an-app)
    "SELECT dayid, userid, date FROM days WHERE userid = ? AND date = ?"
    (user-userid user) datestring)))

(provide initialize-app!
         user-days user-day user-insert-day!
         day-insert-timechunk! day-update-timechunk! day-remove-timechunk!
         app-users app-user app-insert-user!
         app-categories app-insert-category! app-remove-category!
         user-name day-dayid
         category-name category-color
         user->jsexpr timechunk->jsexpr category->jsexpr
         day-timechunks)
